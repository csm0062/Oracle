-------------------29---------------------
--1) 어제 만든 SCORE_STGR 테이블의 SNO 컬럼에 INDEX를 추가하세요.
CREATE INDEX SCORE_STGR_SNO_IDX
	ON SCORE_STGR(SNO);

--2) 어제 만든 ST_COURSEPF 테이블의 SNO, CNO, PNO 다중 컬럼에 INDEX를 추가하세요.
CREATE INDEX ST_COURSEPF_SNO_CNO_PNO_IDX
	ON ST_COURSEPF(SNO, CNO, PNO);
-------------------30---------------------
--뷰 이름은 자유
--1) 학생의 평점 4.5 만점으로 환산된 정보를 검색할 수 있는 뷰를 생성하세요.
CREATE OR REPLACE VIEW V_STUDENT_AVR(
	COURSE_NAME,
	STUDENT_NAME,
	AVR_RE
) AS (
	SELECT C.CNAME
		 , ST.SNAME
		 , (ST.AVR / 4.0) * 4.5
		FROM SCORE SC
		JOIN COURSE C
		  ON SC.CNO = C.CNO
		JOIN STUDENT ST
		  ON ST.SNO = SC.SNO
);

--2) 각 과목별 기말고사 평균 점수를 검색할 수 있는 뷰를 생성하세요.
CREATE OR REPLACE VIEW V_COURSE_MAJOR_AVGRES(
	COURSE_NUM,
	COURSE_NAME,
	AVG_RESULT
) AS (
	SELECT SC.CNO
		 , C.CNAME
		 , ROUND(AVG(SC.RESULT), 2)
		FROM SCORE SC
		JOIN COURSE C
		  ON SC.CNO = C.CNO
		GROUP BY SC.CNO, C.CNAME
);

--3) 각 사원과 관리자(MGR)의 이름을 검색할 수 있는 뷰를 생성하세요.
CREATE OR REPLACE VIEW V_EMP_MGR_SEARCH (
	EMP_ENO,
	EMP_ENAME,
	EMP_MGR
) AS (
	SELECT ENO
		 , ENAME
		 , MGR
		 FROM EMP
);


--4) 각 과목별 기말고사 평가 등급(A~F)까지와 해당 학생 정보를 검색할 수 있는 뷰를 생성하세요.
CREATE OR REPLACE VIEW V_COURSE_RESULT_GRADE(
	COURSE_CNO,
	COURSE_CNAME,
	SCORE_RESULT,
	STUDENT_SNAME,
	SCGRADE_GRADE
) AS ( 
	SELECT C.CNO
		 , C.CNAME
		 , SC.RESULT
		 , ST.SNAME
		 , GR.GRADE
		 FROM SCORE SC
		 JOIN COURSE C
		   ON SC.CNO = C.CNO
		 JOIN STUDENT ST
		   ON ST.SNO = SC.SNO
		 JOIN SCGRADE GR
		   ON SC.RESULT BETWEEN GR.LOSCORE AND GR.HISCORE
);


--5) 물리학과 교수의 과목을 수강하는 학생의 명단을 검색할 뷰를 생성하세요.
CREATE OR REPLACE VIEW STUDENTLIST_PHYSICS_COURSE(
	STUDENT_SNO,
	STUDENT_SNAME,
	COURSE_CNAME,
	PROFESSOR_SECTION
) AS (
	SELECT ST.SNO
		 , ST.SNAME
		 , C.CNAME
		 , P.SECTION 
		 FROM STUDENT ST
		 JOIN SCORE SC
		   ON ST.SNO = SC.SNO
		 JOIN COURSE C
		   ON SC.CNO = C.CNO
		 JOIN PROFESSOR P
		   ON C.PNO = P.PNO
		 WHERE P.SECTION = '물리'
);
-------------------31---------------------
--1) 4.5 환산 평점이 가장 높은 3인의 학생을 검색하세요.
SELECT ROWNUM
	 , A.SNO
	 , A.SNAME
	 , A.AVR_RE
	 FROM(
	 	SELECT SNO
	 		 , SNAME
	 		 , (AVR / 4) * 4.5 AS AVR_RE
	 		 FROM STUDENT
	 		 ORDER BY AVR_RE DESC
	 )A
	 WHERE ROWNUM <=3;

--2) 기말고사 과목별 평균이 높은 3과목을 검색하세요.
SELECT ROWNUM
	 , A.CNAME
	 , A.AVG_RES
	 FROM(
	 	SELECT C.CNAME
	 		 , AVG(SC.RESULT) AS AVG_RES
	 		 FROM COURSE C
	 		 JOIN SCORE SC
	 		   ON C.CNO = SC.CNO
	 		 GROUP BY C.CNAME
	 		 ORDER BY AVG_RES DESC
	 )A
	 WHERE ROWNUM <=3;

--3) 학과별, 학년별, 기말고사 평균이 순위 3까지를 검색하세요.(학과, 학년, 평균점수 검색)
SELECT ROWNUM
	 , A.SYEAR
	 , A.MAJOR
	 , A.AVG_RESULT
	 FROM(
	 	SELECT ST.MAJOR
	 		 , ST.SYEAR
	 		 , AVG(SC.RESULT) AS AVG_RESULT
	 		 FROM STUDENT ST
	 		 JOIN SCORE SC
	 		   ON ST.SNO = SC.SNO
	 		 GROUP BY ST.MAJOR, ST.SYEAR
	 		 ORDER BY AVG_RESULT DESC
	 )A
	 WHERE ROWNUM <=3;

--4) 기말고사 성적이 높은 과목을 담당하는 교수 3인을 검색하세요.(교수이름, 과목명, 평균점수 검색)
SELECT ROWNUM
	 , A.PNAME
	 , A.CNAME
	 , A.AVG_RES
	 FROM(
	 	SELECT P.PNAME
	 		 , C.CNAME
	 		 , AVG(SC.RESULT) AS AVG_RES
	 		 FROM COURSE C
	 		 JOIN SCORE SC
	 		   ON C.CNO = SC.CNO
	 		 JOIN PROFESSOR P
	 		   ON C.PNO = P.PNO
	 		 GROUP BY C.CNAME, P.PNAME
	 		 ORDER BY AVG_RES DESC
	 )A
	 WHERE ROWNUM <=3;

--5) 교수별로 현재 수강중인 학생의 수를 검색하세요.
SELECT
	P.PNAME,
	COUNT(SC.SNO) AS STUDENT_COUNT
	FROM PROFESSOR P
	JOIN COURSE C 
	ON P.PNO = C.PNO
	JOIN SCORE SC 
	ON C.CNO = SC.CNO
	GROUP BY P.PNAME
	ORDER BY P.PNAME;
-------------------32---------------------
--1) CNO이 PK인 COURSE_PK 테이블을 생성하세요.(1번 방식으로)
CREATE TABLE COURSE_PK1(
	CNO VARCHAR2(8) PRIMARY KEY,
	CNAME VARCHAR2(20),
	ST_NUM NUMBER(1, 0),
	PNO VARCHAR2(8)
);

--2) PNO이 PK인 PROFESSOR_PK 테이블을 생성하세요.(2번 방식으로)
CREATE TABLE PROFESSOR_PK2(
	PNO NUMBER(4),
	PNAME VARCHAR2(20),
	SECTION VARCHAR2(10),
	ORDERS VARCHAR2(10),
	HIREDATE DATE,
	CONSTRAINT PK_PROFESSOR_PNO PRIMARY KEY(PNO)
);

--3) PF_TEMP 테이블에 PNO을 PK로 추가하세요.
ALTER TABLE PF_TEMP ADD CONSTRAINT PK_PF_TEMP_SNO PRIMARY KEY(PNO);

--4) COURSE_PROFESSOR 테이블에 CNO, PNO을 PK로 추가하세요. (CNUM, PNUM 으로 존재)?? NULL값이 있는데?
ALTER TABLE COURSE_PROFESSOR ADD CONSTRAINT PK_COURSE_PROFESSOR_CNUM_PNUM PRIMARY KEY(CNUM, PNUM);


--5) BOARD_NO(NUMBER)를 PK로 갖으면서 BOARD_TITLE(VARCHAR2(200)), BOARD_CONTENT(VARCHAR2(2000)), 
--   BOARD_WRITER(VARCHAR2(20)), BOARD_FRGT_DATE(DATE), BOARD_LMDF_DATE(DATE) 컬럼을 갖는 T_BOARD 테이블을 생성하세요.
CREATE TABLE T_BOARD (
	BOARD_NO NUMBER  PRIMARY KEY,
	BOARD_TITLE VARCHAR2(200),
	BOARD_CONTENT VARCHAR2(2000),
	BOARD_WRITER VARCHAR2(20),
	BOARD_FRGT_DATE DATE,
	BOARD_LMDF_DATE DATE
);

--6) BOARD_NO(NUMBER), BOARD_FILE_NO(NUMBER)를 PK로 갖으면서 BOARD_FILE_NM(VARCHAR2(200)), BOARD_FILE_PATH(VARCHAR2(2000)),
--   ORIGIN_FILE_NM(VARCHAR2(200)) 컬럼을 갖는 T_BOARD_FILE 테이블을 생성하세요.
CREATE TABLE T_BOARD_FILE (
	BOARD_NO NUMBER,
	BOARD_FILE_NO NUMBER,
	BOARD_FILE_NM VARCHAR2(200),
	BOARD_FILE_PATH VARCHAR2(2000),
	ORIGIN_FILE_NM VARCHAR2(200),
	CONSTRAINT PK_BOARD_NO_FILE_NO PRIMARY KEY(BOARD_NO, BOARD_FILE_NO)
);


--7) 다음 구조를 갖는 테이블을 생성하세요.
--   T_SNS                              T_SNS_DETAIL                        T_SNS_UPLOADED
--   SNS_NO(PK)    SNS_NM               SNS_NO(PK, FK)   SNS_BEN            SNS_NO(PK, FK)    SNS_UPL_NO(PK)
--     1            페북                   1               4000                   1                  1
--     2           인스타                  2               10000                  1                  2
--     3           트위터                  3               30000                  2                  1
--                                                                               2                  2

CREATE TABLE T_SNS (
	SNS_NO NUMBER PRIMARY KEY,
	SNS_NM VARCHAR2(20)
);

INSERT INTO T_SNS
VALUES (1, '페북');
INSERT INTO T_SNS
VALUES (2, '인스타');
INSERT INTO T_SNS
VALUES (3, '트위터');
COMMIT;

SELECT *
	FROM T_SNS;

CREATE TABLE T_SNS_DETAIL (
	SNS_NO NUMBER,
	SNS_BEN NUMBER,
	CONSTRAINT PK_SNS_PK1_FK1_SNS_NO PRIMARY KEY(SNS_NO),
	CONSTRAINT FK_SNS_PK1_FK1_SNS_NO FOREIGN KEY(SNS_NO)
		REFERENCES T_SNS(SNS_NO)
);

INSERT INTO T_SNS_DETAIL
VALUES (1, 4000);
INSERT INTO T_SNS_DETAIL
VALUES (2, 10000);
INSERT INTO T_SNS_DETAIL
VALUES (3, 30000);
COMMIT;


SELECT *
	FROM T_SNS_DETAIL;

CREATE TABLE T_SNS_UPLOADED (
	SNS_NO NUMBER,
	SNS_UPL_NO NUMBER,
	CONSTRAINT PK_SNS_NO_UPL_NO PRIMARY KEY(SNS_NO,SNS_UPL_NO),
	CONSTRAINT FK_SNS_NO FOREIGN KEY(SNS_NO)
		REFERENCES T_SNS_DETAIL(SNS_NO)
);

INSERT INTO T_SNS_UPLOADED
VALUES (1, 1);
INSERT INTO T_SNS_UPLOADED
VALUES (1, 2);
INSERT INTO T_SNS_UPLOADED
VALUES (2, 1);
INSERT INTO T_SNS_UPLOADED
VALUES (2, 2);
COMMIT;

SELECT *
	FROM T_SNS_UPLOADED;



